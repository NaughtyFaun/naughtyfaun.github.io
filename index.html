<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D</title>
    <script type="text/javascript" language="javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.js"></script>
    <script type="text/javascript" language="javascript" src="OBJLoader.js"></script>
    <style type="text/css">
    <!-- BODY {background:none transparent;}-->
    </style>
</head>
<body>
<div id="container"></div>
<script>
    Math.clamp=function(a,b,c){return Math.max(b,Math.min(c,a));};

    var clock = new THREE.Clock();
    // Set the scene size.
    const WIDTH = 400;
    const HEIGHT = 300;

    // Set some camera attributes.
    const VIEW_ANGLE = 45;
    const ASPECT = WIDTH / HEIGHT;
    const NEAR = 0.1;
    const FAR = 10000;

    // Get the DOM element to attach to
    const container =
        document.querySelector('#container');

    // Create a WebGL renderer, camera
    // and a scene
    const renderer = new THREE.WebGLRenderer({alpha:true});
    const camera =
        new THREE.PerspectiveCamera(
            VIEW_ANGLE,
            ASPECT,
            NEAR,
            FAR
        );

    const scene = new THREE.Scene();

    // Add the camera to the scene.
    scene.add(camera);

    // Start the renderer.
    renderer.setSize(WIDTH, HEIGHT);

    // Attach the renderer-supplied
    // DOM element.
    container.appendChild(renderer.domElement);


    // create the sphere's material
    var material =
        new THREE.MeshLambertMaterial(
            {
                color: 0xCC0000
            });

    // // Set up the sphere vars
    // const RADIUS = 50;
    // const SEGMENTS = 16;
    // const RINGS = 16;

    // // Create a new mesh with
    // // sphere geometry - we will cover
    // // the material next!
    // const sphere = new THREE.Mesh(
    //     new THREE.SphereGeometry(
    //         RADIUS,
    //         SEGMENTS,
    //         RINGS),
    //
    //     material);
    //
    // // Move the Sphere back in Z so we
    // // can see it.
    // sphere.position.z = -300;
    //
    // // Finally, add the sphere to the scene.
    // scene.add(sphere);



        // instantiate a loader
    var loader = new THREE.OBJLoader();

    var heart;
    var newAnims = [];

    // load a resource
    loader.load(
        // resource URL
        'heart.obj',
        // called when resource is loaded
        function ( object ) {

            heart = object;
            heart.position.z = -300;
            var scale = 100;
            heart.scale.multiplyScalar(80);

            object.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.material = material;
                }
            });

            newAnims[newAnims.length] = new LikeAnimation(heart, new THREE.Vector3( 0, -100, -300 ), new THREE.Vector3( 0, 80, -300 ), 2);
            var anotherHeart = heart.clone();
            anotherHeart.scale.multiplyScalar(0.7);
            scene.add(anotherHeart);
            newAnims[newAnims.length] = new LikeAnimation(anotherHeart, new THREE.Vector3( 50, -100, -330 ), new THREE.Vector3( 50, -20, -330 ), 2);
            anotherHeart = heart.clone();
            anotherHeart.scale.multiplyScalar(0.7);
            scene.add(anotherHeart);
            newAnims[newAnims.length] = new LikeAnimation(anotherHeart, new THREE.Vector3( -50, -100, -280 ), new THREE.Vector3( -50, 0, -280 ), 2);


            scene.add( object );
        },
        function ( xhr ) {
            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
        },
        function ( error ) {
            console.log( 'An error happened' );
        }
    );


    var LikeAnimation = function(obj, startPos, endPos, duration)
    {

        this.obj = obj;
        this.startPos = startPos.clone();
        this.endPos   = endPos.clone();
        this.duration = duration;
        this.spin     = new THREE.Vector3(0, 180, 0);

        this.spin.multiplyScalar(Math.PI / 180);

        this.elapsedTime = 0;
        this.speed       = this.endPos.clone().sub(this.startPos).divideScalar(this.duration);

        // console.log(this.obj);
        console.log(this.speed);

        //this.obj.position.set(this.startPos.x, this.startPos.y, this.obj.position.z);
        this.obj.position.copy(this.startPos);

        material.transparent = true;
        material.opacity = 0;

        return this;
    };

    LikeAnimation.prototype.UpdateFrame = function(deltaTime)
    {
        this.elapsedTime += deltaTime;

        if (this.elapsedTime > this.duration)
        {
            this.obj.position.copy(this.startPos);
            this.obj.rotation = new THREE.Vector3(0, 0, 0);
            this.elapsedTime = 0;
        }

        if (this.elapsedTime < this.duration*0.2)
        {
            material.opacity = Math.clamp(this.elapsedTime/(this.duration*0.2), 0, 1);
        }
        else if (this.elapsedTime > this.duration*0.8)
        {
            material.opacity = Math.clamp((this.duration - this.elapsedTime)/(this.duration*0.19), 0, 1);
        }
        else
        {
            material.opacity = 1;
        }


        // material.transparent = true;

        this.obj.position.add(this.speed.clone().multiplyScalar(deltaTime));

        var curRot = this.obj.rotation.toVector3();
        this.obj.rotation.setFromVector3(curRot.add(this.spin.clone().multiplyScalar(deltaTime)));
    };


    // create a point light
    const pointLight = new THREE.PointLight(0xFFFFFF);

    // set its position
    pointLight.position.x = 10;
    pointLight.position.y = 50;
    pointLight.position.z = 130;

    // add to the scene
    scene.add(pointLight);


    function update()
    {
        if (heart != undefined)
        {
            var deltaTime = clock.getDelta();
            for (i = 0; i < newAnims.length; i++)
            {
                newAnims[i].UpdateFrame(deltaTime)
            }

        }

        // Draw!
        renderer.render(scene, camera);
        requestAnimationFrame(update);
    }

    renderer.render(scene, camera);
    requestAnimationFrame(update);

</script>
</body>
</html>